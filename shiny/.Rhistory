dpois(x=7, lambda = 7)
dpois(x=18, lambda = 7)
dpois(x=13, lambda = 7)
dpois(x=seq(0,20,1), lambda = 7)
sum(dpois(x=seq(0,20,1), lambda = 7))
dpois(x=seq(0,20,1), lambda = 7)
dpois(x=seq(0,20,1), lambda = 7)*100
pars <- expand.grid(results=13, true_probs=seq(0,1,0.01))
pars$prior <- dunif(pars$true_probs, min=0, max=0.2)
pars$likelihood <- dbinom(x=pars$results, size=100, prob=pars$true_probs)
pars$probability <- (pars$prior * pars$likelihood) / sum((pars$prior * pars$likelihood))
res13 <- pars %>% filter(results==13)
res13$probability <- res13$probability / sum(res13$probability)
pars <- expand.grid(results=seq(0,100,by=1), true_probs=seq(0,1,0.01))
pars$prior <- dunif(pars$true_probs, min=0, max=0.2)
#Prob of having each true_prob be the actual underlying probability, given a prior of uniform 0->0.2
pars$likelihood <- dbinom(x=pars$results, size=100, prob=pars$true_probs)
# Prob of getting each result # out of 100 if the corresponding true_prob was the actual underlying prob
pars$probability <- (pars$prior * pars$likelihood) / sum((pars$prior * pars$likelihood))
# Given our 0->0.2 uniform prior, the prob of each true_prob/result combination occurring
res13 <- pars %>% filter(results==13)
res13$probability <- res13$probability / sum(res13$probability)
# We ACTUALLY saw 13 events. So what was the most likely underlying true prob?
dnorm(x = 15, mean = 17, sd = 4)
dnorm(x = 15, mean = 17, sd = 3)
dnorm(x = 15, mean = 17, sd = 2)
dnorm(x = 15, mean = 17, sd = 1)
temp <- c(19, 23, 20, 17, 23)    # Actual temps we've observed
mu <- seq(8, 30, by = 0.5)       # Prior (normal distrib.) mean of temps
sigma <- seq(0.1, 10, by = 0.3)  # Prior (normal distrib.) sd of temps
pars <- expand.grid(mu = mu, sigma = sigma)   # All combinations of our prior mu and sigma
dnorm(pars$mu, mean = 18, sd = 5)
pars$mu_prior <- dnorm(pars$mu, mean = 18, sd = 5)   # The prob of each mu being the true mu, given our prior (normal)
View(pars)
pars$sigma_prior <- dunif(pars$sigma, min = 0, max = 10)   # The prob of each sd being the true sd, given our prior (unif.)
pars$prior <- pars$mu_prior * pars$sigma_prior    # Combined prior (likelihood of each combined mu/sd outcome occurring)
dnorm(temp, pars$mu[1], pars$sigma[1])
dnorm(temp, pars$mu[100], pars$sigma[100])
for(i in 1:nrow(pars)) {                                  # For each row in pars, calc the likelihood of each temp
likelihoods <- dnorm(temp, pars$mu[i], pars$sigma[i])   # occurring if that mu/sd combo were the true underlying params
pars$likelihood[i] <- prod(likelihoods)                 # (multiply the probs of each temp)
}
pars$probability <- pars$likelihood * pars$prior          # Create probs from likelihoods and normalize
pars$probability <- pars$probability / sum(pars$probability)
sample_indices <- sample( 1:nrow(pars), size = 10000,    # Randomly sample pars row indices based on their respective probs
replace = TRUE, prob = pars$probability)
pars_sample <- pars[sample_indices, c('mu', 'sigma')]    # Extract these rows
View(pars_sample)
hist(pars_sample$mu, 30)                                 # Observe the probabilistic means
pred_temp <- rnorm(10000, mean = pars_sample$mu, sd = pars_sample$sigma)   # Create 10K hypothetical temps using posteriors
ecdf(pred_temp)(18)    # Cumulative distribution of getting less than 18 degrees
pred_temp <- rnorm(10000, mean = pars_sample$mu, sd = pars_sample$sigma)   # Create 10K hypothetical temps using posteriors
ecdf(pred_temp)(18)    # Cumulative distribution of getting less than 18 degrees
pred_temp <- rnorm(10000, mean = pars_sample$mu, sd = pars_sample$sigma)   # Create 10K hypothetical temps using posteriors
ecdf(pred_temp)(18)    # Cumulative distribution of getting less than 18 degrees
install.packages("BEST")
library(BEST)
library(BEST)
install.packages("BEST")
library(BEST)
library(BEST)
install.packages("rjags")
library(rjags)
library(BEST)
iq <- c(55, 44, 34, 18, 51, 40, 40, 49, 48, 46)         # observations of zombie IQ
iq <- c(55, 44, 34, 18, 51, 40, 40, 49, 48, 46)         # observations of zombie IQ
library(BEST)
library(BEST)
iq <- c(55, 44, 34, 18, 51, 40, 40, 49, 48, 46)         # observations of zombie IQ
BESTmcmc(iq)
fit <- BESTmcmc(iq)
fit$mu
temp <- c(19, 23, 20, 17, 23)
BESTmcmc(temp)
plot(fit)
iq_brains <- c(44, 52, 42, 66, 53, 42, 55, 57, 56, 51)      # Compare IQ of zombies eating brains
iq_regular <- c(55, 44, 34, 18, 51, 40, 40, 49, 48, 46)     # with IQ of zombies eating regular food
best_posterior <- BESTmcmc(iq_brains, iq_regular)
plot(best_posterior)
library(rjags)
z <- rbinom(n = 10000, size=10, prob=0.6)
hist(z)
table(z)
rm(z)
hist(rbeta(10000, 45, 55))
p1 <- rbeta(10000, 45, 55)
p2 <- rbeta(10000, 51, 65)
c(p1, p2)
data.frame('a'=c(p1, p2))
data.frame('probs'=c(p1, p2)), c(rep('a',10000), rep('b', 10000))
data.frame('probs'=c(p1, p2), c(rep('a',10000), rep('b', 10000)))
p3 <- data.frame('probs'=c(p1, p2), c(rep('a',10000), rep('b', 10000)))
View(p3)
p3 <- data.frame('probs'=c(p1, p2), 'groups'=c(rep('a',10000), rep('b', 10000)))
library(ggplot2)
ggplot(p3, aes(x=probs)) + geom_histogram()
ggplot(p3, aes(x=probs)) + geom_histogram(bins=50)
ggplot(p3, aes(x=probs, color=groups)) + geom_histogram(bins=50)
ggplot(p3, aes(x=probs, fil=groups)) + geom_histogram(bins=50)
ggplot(p3, aes(x=probs, fill=groups)) + geom_histogram(bins=50)
ggplot(p3, aes(x=probs, fill=groups)) + geom_histogram(bins=50, stat='identity')
ggplot(p3, aes(x=probs, fill=groups)) + geom_density()
p1 <- rbeta(10000, 45, 55)
p2 <- rbeta(10000, 51, 65)
p3 <- data.frame('probs'=c(p1, p2), 'groups'=c(rep('a',10000), rep('b', 10000)))
ggplot(p3, aes(x=probs, fill=groups)) + geom_density()
p1 <- rbeta(10000, 45, 55)
p2 <- rbeta(10000, 51, 59)
p3 <- data.frame('probs'=c(p1, p2), 'groups'=c(rep('a',10000), rep('b', 10000)))
ggplot(p3, aes(x=probs, fill=groups)) + geom_density()
library(rjags)
library(rjags)
install.packages("rjags")
library(rjags)
library(rjags)
install.packages("rjags")
library(rjags)
rjags::list.modules()
true_props <- runif(50000, min=0, max=0.2)
results <- rbinom(50000, 1000, true_props)
plot(results, true_props)
true_props <- runif(50000, min=0, max=0.2)
results <- rbinom(50000, 1000, true_props)
plot(results, true_props)
prior <- as.data.frame(cbind(true_props, results))
posterior <- prior[prior$results==125,]
hist(posterior$true_props, breaks = 25)
posterior$n_events <- rbinom(nrow(posterior), 1000, prob=posterior$true_props)
hist(posterior$true_props, breaks = 25)      # How many events are we expecting to see?
hist(posterior$n_events, breaks = 25)      # How many events are we expecting to see?
sum(posterior$n_events >= 110) / nrow(posterior)
true_props <- rbeta(50000, shape1=5, shape2=95)
results <- rbinom(50000, 1000, true_props)
hist(results, breaks=25)
plot(results, true_props)
hist(results, breaks=25)
prior <- as.data.frame(cbind(true_props, results))
posterior <- prior[prior$results==80,]   # Find all the true underlying proportions when results were 80 events
hist(true_props, breaks=25, xlim = c(0,0.2))
hist(posterior$true_props, breaks=10, xlim = c(0, 0.2))   # The updated distribution is way higher than before
mean_events <- runif(100000, min = 0, max = 80)
mean_events
results <- rpois(100000, lambda=mean_events)    # Simulate 100,000 time units given the prior, see how many events happened
prior <- as.data.frame(cbind(mean_events, results))
head(prior)
posterior <- prior[prior$results==45,]
hist(posterior$mean_events, breaks=100)
View(posterior)
dbinom(13, size=100, prob = 0.1)       # prob that exactly 13/100 successes would happen, given a true 0.10 success prob
dbinom(13, size=100, prob = 0.1) + dbinom(14, size=100, prob = 0.1) # prob of 13 or 14/100
dbinom(seq(1,100,1), size=100, prob=0.1)  # probs of getting exactly X/100 successes for X in range(1,100)
dunif(x=0.12, min=0, max=0.2) # uniform probability between 0 and 0.2, the prob density of getting 0.12
pars <- expand.grid(results=seq(0,100,by=1), true_probs=seq(0,1,0.01))
head(pars)
pars$prior <- dunif(pars$true_probs, min=0, max=0.2)
head(pars)
pars$likelihood <- dbinom(x=pars$results, size=100, prob=pars$true_probs)
head(pars)
pars$probability <- (pars$prior * pars$likelihood) / sum((pars$prior * pars$likelihood))
head(pars)
sum(pars$probability)
View(pars)
res13 <- pars %>% filter(results==13)
library(dplyr)
res13 <- pars %>% filter(results==13)
res13$probability <- res13$probability / sum(res13$probability)
View(res13)
temp <- c(19, 23, 20, 17, 23)    # Actual temps we've observed
mu <- seq(8, 30, by = 0.5)       # Prior (normal distrib.) mean of temps
sigma <- seq(0.1, 10, by = 0.3)  # Prior (unif distrib.) sd of temps
pars <- expand.grid(mu = mu, sigma = sigma)   # All combinations of our prior mu and sigma
head(pars)
head(pars)
pars$mu_prior <- dnorm(pars$mu, mean = 18, sd = 5)   # The prob of each mu being the true mu, given our prior (normal)
pars$sigma_prior <- dunif(pars$sigma, min = 0, max = 10)   # The prob of each sd being the true sd, given our prior (unif.)
pars$prior <- pars$mu_prior * pars$sigma_prior    # Combined prior (likelihood of each combined mu/sd outcome occurring)
head(pars)
View(pars)
likelihoods <- dnorm(temp, pars$mu[1], pars$sigma[1])
for(i in 1:nrow(pars)) {                                  # For each row in pars, calc the likelihood of each temp
likelihoods <- dnorm(temp, pars$mu[i], pars$sigma[i])   # occurring if that mu/sd combo were the true underlying params
pars$likelihood[i] <- prod(likelihoods)                 # (multiply the probs of each temp)
}
temp
pars$probability <- pars$likelihood * pars$prior          # Create probs from likelihoods and normalize
pars$probability <- pars$probability / sum(pars$probability)
sample_indices <- sample( 1:nrow(pars), size = 10000,    # Randomly sample pars row indices based on their respective probs
replace = TRUE, prob = pars$probability)
pars_sample <- pars[sample_indices, c('mu', 'sigma')]    # Extract these rows
hist(pars_sample$mu, 30)                                 # Observe the probabilistic means
pred_temp <- rnorm(10000, mean = pars_sample$mu, sd = pars_sample$sigma)   # Create 10K hypothetical temps using posteriors
ecdf(pred_temp)(18)    # Cumulative distribution of getting less than 18 degrees
pred_temp <- rnorm(10000, mean = pars_sample$mu, sd = pars_sample$sigma)   # Create 10K hypothetical temps using posteriors
ecdf(pred_temp)(18)    # Cumulative distribution of getting less than 18 degrees
1-ecdf(pred_temp)(18)    # Cumulative distribution of getting less than 18 degrees
library(htmltab)
htmltab('https://kenpom.com/index.php?y=2018')
z <- htmltab('https://kenpom.com/index.php?y=2018')
View(z)
rm(z)
library(reticulate)
import("os")
os <- import("os")
os$listdir()
os$getcwd()
sklearn <- import("sklearn")
sklearn <- import("sklearn")
numpy <- import("numpy")
pandas <- import("pandas")
sklearn <- import("sklearn")
sklearn <- import("scikit-learn")
install.packages("shinydashboard")
install.packages("shinydashboardPlus")
install.packages("DBI")
install.packages("RMySQL")
tracking.example <- read_csv(file.tracking)
library(tidyverse)
file.tracking <- "https://raw.githubusercontent.com/nfl-football-ops/Big-Data-Bowl/master/Data/tracking_gameId_2017090700.csv"
tracking.example <- read_csv(file.tracking)
View(tracking.example)
table(tracking.example$playId)
table(tracking.example$playId, tracking.example$displayName)
p <- filter(tracking.example, displayName != 'football')
View(p)
library(rjags)
library(tidyverse)
file.tracking <- "https://raw.githubusercontent.com/nfl-football-ops/Big-Data-Bowl/master/Data/tracking_gameId_2017090700.csv"
tracking.example <- read_csv(file.tracking)
View(tracking.example)
library(rjags)
n <- 30
p <- runif(1, 0 1)
p <- runif(1, 0, 1)
rbinom(1, p, n)
rbinom(1, n, p)
rbinom(1, n, p)
x <- rbinom(1, n, p)
rm(n, p x)
rm(n, p, x)
m <- model {
n <- 30
p ~ dunif(0,1)
x ~ dbinom(p, n)
}
}"
m <- "model {
m <- "model {
n <- 30
p ~ dunif(0,1)
x ~ dbinom(p, n)
}"
d <- "f"
rm(d)
m <- """model {
m <- """model {
n <- 30
p ~ dunif(0,1)
x ~ dbinom(p, n)
}"""
m <- "
m <- "
model {
n <- 30
p ~ dunif(0,1)
x ~ dbinom(p, n)
}
m <- "
model {
n <- 30
p ~ dunif(0,1)
x ~ dbinom(p, n)
}
"
d <- jags.model(textConnection(m), data = list(x=10))
d
d$ptr()
d$data()
d$model()
library(BEST)
BESTmcmc(y1 = c(5, 7, 6, 6, 5, 6, 7), y2 = c(1, 2, 3, 3, 1))
mean(c(5, 7, 6, 6, 5, 6, 7))
mean(c(1, 2, 3, 3, 1))
BESTmcmc(y1 = c(5, 7, 6, 6, 5, 6, 7), y2 = c(1, 2, 34, 3, 1))
mean(c(1, 2, 34, 3, 1))
install.packages("rstan")
# server----
server <- function(input, output, session){
# server - Pitcher tab----
# Change input for number of pitches to cluster on
max_n_pitches <- reactive(length(pitcherTopPitches(player_name = input$player_choice, n_pitches = 100, metrics = FALSE)))
isolate(observe({updateSelectInput(session = session, inputId = 'n_pitches_choice', choices = seq(1:max_n_pitches()), selected = min(max_n_pitches(), 2))}))
# Scatterplot box title text
pitch_mix_string <- reactive(paste0('&nbsp;', paste0(input$pitch_mix_choice, collapse = ', '), '<br><h5>&nbsp;', input$player_choice_2, '</h5>'))
output$scatterplot_box_title_2 <- renderUI({
HTML(pitch_mix_string())
})
# List of neighbors text
pitcher_neighbors <- reactive(nearestNeighborsFromPitcher(player_name = input$player_choice, n_pitches = as.numeric(input$n_pitches_choice), k = 5, type = 'NONE', scale = TRUE, nonmetric = TRUE, spin_ratio_importance = 2 ** as.numeric(input$spin_ratio_importance_choice)))
pitcher_neighbors_formatted <- reactive(pitcher_neighbors() %>% mutate(neighbor_formatted=paste0(row_number(), '. ', neighbors_names)))
neighbors_text_string <- reactive(paste0(pitcher_neighbors_formatted()$neighbor_formatted, ' - ', sprintf('%.2f', round(pitcher_neighbors_formatted()$neighbors_dists, 4)), collapse = '<br>'))
# List of metrics text
metrics_df <- reactive(pitcherTopPitches(player_name = input$player_choice, n_pitches = input$n_pitches_choice, metrics = TRUE))
metrics_text_string <- reactive(paste0(metrics_df()$pitch_list, ' - ', metrics_df()$velocity_list, ' MPH / ', metrics_df()$spin_rate_list, ' RPM', collapse = '<br>'))
# Data table of all possible neighbors
all_possible_neighbors <- reactive(allNeighborsFromPitcher(player_name = input$player_choice, n_pitches = as.numeric(input$n_pitches_choice), type = 'NONE', scale = TRUE, nonmetric = TRUE, spin_ratio_importance = 2 ** as.numeric(input$spin_ratio_importance_choice)))
# Separate datasets for selected pitcher and non-selected pitchers
mds_full <- reactive(createMDSFromPitcher(player_name = input$player_choice, n_pitches = input$n_pitches_choice))
mds_selection_yes <- reactive(filter(mds_full(), player_name == input$player_choice))
mds_selection_neighbors <- reactive(filter(mds_full(), player_name %in% pitcher_neighbors()$neighbors_names))
mds_selection_no <- reactive(filter(mds_full(), !(player_name %in% c(input$player_choice, pitcher_neighbors()$neighbors_names))))
n_possible_neighbors <- reactive(nrow(mds_selection_neighbors()) + nrow(mds_selection_no()))
# Disclaimer text
output$disclaimer_text <- renderUI({
HTML(paste0('<center><h6>', disclaimer_text, '</h6></center>'))
})
# Global geom aesthetics
axis_text_size <- 10
point_size = 3.5
# OUTPUT - scatterplot
output$scatterplot <- renderPlotly({
req(input$player_choice)
if(input$points_format_choice == 'Points'){
p <- ggplot(NULL, aes(x=V1, y=V2, text=player_name)) +
geom_point(data=mds_selection_no(),
shape=21,
size=point_size,
alpha=0.5,
color='blue3',
fill='skyblue2',
stroke=0.1) +
geom_point(data=mds_selection_neighbors(),
shape=21,
size=point_size,
alpha=0.75,
color='orange2',
fill='orange') +
geom_point(data=mds_selection_yes(),
shape=21,
size=point_size,
alpha=0.75,
color='red2',
fill='red')
} else {
p <- ggplot(NULL, aes(x=V1, y=V2, text=player_name)) +
geom_text(data=mds_selection_no(), aes(label=player_name), color='steelblue3', size=3) +
geom_text(data=mds_selection_neighbors(), aes(label=player_name), color='orange', size=3) +
geom_text(data=mds_selection_yes(), aes(label=player_name), color='red3', size=3) +
scale_x_continuous(expand = c(.15, .15))
}
p2 <- p +
theme_minimal() +
labs(title = NULL, x='Dimension 1*', y='Dimension 2*') +
theme(text = element_text(family='Source Sans Pro'),
axis.title.x = element_text(size=axis_text_size, face='italic'),
axis.title.y = element_text(size=axis_text_size, face='italic'),
axis.text.x = element_blank(),
axis.text.y = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
ggplotly(p2, tooltip = c('text')) %>%
layout(xaxis = list(side = 'top'))
})
# OUTPUT - neighbors list
output$neighbors_list <- renderUI({
req(input$player_choice)
HTML(paste0('<b>Nearest neighbors (of ', n_possible_neighbors(), ') :</b><br>', neighbors_text_string(), '<br>&nbsp;'))
})
# OUTPUT - metrics list
output$metrics_list <- renderUI({
req(input$player_choice)
HTML(paste0('<b>Pitch metrics:</b><br>', metrics_text_string(), '<br>'))
})
# OUTPUT - data table
output$neighbors_table <- renderDataTable({
all_possible_neighbors()
},
rownames = FALSE,
options = list(
autoWidth = TRUE,
columnDefs = list(list(width = '5px', targets = 0),
list(width = '150px', targets = 1)),
dom = c('tp'),
pageLength = 10,
processing = FALSE
))
# server - Pitch mix tab----
# Change input for possible pitchers to highlight
possible_highlighted_pitchers <- reactive(nearestNeighborsFromPitchList(pitch_list = input$pitch_mix_choice, k = 1, type = 'NONE', spin_ratio_importance = 2 ** as.numeric(input$spin_ratio_importance_choice_2))$player_name)
observe({updateSelectizeInput(session = session, inputId = 'player_choice_2', choices = as.character(possible_highlighted_pitchers()))})
# Scatterplot box title text (2)
pitches_chosen_string <- reactive(paste0(pitcherTopPitches(player_name = input$player_choice, n_pitches = input$n_pitches_choice, metrics = FALSE), collapse = ', '))
output$scatterplot_box_title <- renderUI({
req(input$player_choice)
HTML(paste0(input$player_choice, br(), '<h5>', pitches_chosen_string(), '</h5>'))
})
# Change select text for possible pitchers to highlight
n_possible_highlighted_pitchers <- reactive(length(as.character(possible_highlighted_pitchers())))
output$n_possible_highlighted_pitchers <- reactive(paste0('Highlighted pitcher (of ', as.character(n_possible_highlighted_pitchers()), '):'))
# Collect all possible nearest neighbors and prepare text for top 5
all_possible_neighbors_mix <- reactive(nearestNeighborsWideToLong(nearestNeighborsFromPitchList(pitch_list = input$pitch_mix_choice, k=1e5, type = 'NONE', scale = TRUE, nonmetric = TRUE, spin_ratio_importance = 2 ** as.numeric(input$spin_ratio_importance_choice_2))))
pitcher_neighbors_2 <- reactive(all_possible_neighbors_mix() %>% filter(player_name == input$player_choice_2, num <= 5) %>% mutate(neighbors_formatted = paste0(num, '. ', neighbors_names, ' - ', neighbors_dists)))
five_neighbors_from_mix_text_string <- reactive(paste0(pitcher_neighbors_2()$neighbors_formatted, collapse = '<br>'))
# List of metrics text (2)
metrics_df_2 <- reactive(pitcherMetricsFromPitchList(player_name = input$player_choice_2, pitch_list = input$pitch_mix_choice))
metrics_text_string_2 <- reactive(paste0(metrics_df_2()$pitch, ' - ', metrics_df_2()$velocity, ' MPH / ', metrics_df_2()$spin_rate, ' RPM', collapse = '<br>'))
# Data table of all possible neighbors
all_possible_neighbors_2 <- reactive(allNeighborsFromPitcherWithPitchList(player_name = input$player_choice_2, pitch_list = input$pitch_mix_choice, type = 'NONE', scale = TRUE, nonmetric = TRUE, spin_ratio_importance = 2 ** as.numeric(input$spin_ratio_importance_choice_2)))
# Disclaimer text (2)
output$disclaimer_text_2 <- renderUI({
HTML(paste0('<center><h6>', disclaimer_text, '</h6></center>'))
})
# MDS dataset from pitch list
mds_from_mix <- reactive(createMDSFromPitchList(pitch_list = input$pitch_mix_choice, scale = TRUE, nonmetric = TRUE))
mds_from_mix_yes <- reactive(filter(mds_from_mix(), player_name == input$player_choice_2))
mds_from_mix_neighbors <- reactive(filter(mds_from_mix(), player_name %in% pitcher_neighbors_2()$neighbors_names))
mds_from_mix_no <- reactive(filter(mds_from_mix(), !(player_name %in% c(input$player_choice2, pitcher_neighbors_2()$neighbors_names))))
# OUTPUT - scatterplot_2
output$scatterplot_2 <- renderPlotly({
validate(
need(!is.null(nearestNeighbors(df = prepClustering(pitch_list = input$pitch_mix_choice))), 'Not enough pitchers with this pitch mix!')
)
if(input$points_format_choice_2 == 'Points'){
p <- ggplot(NULL, aes(x=V1, y=V2, text=player_name)) +
geom_point(data=mds_from_mix_no(),
shape=21,
size=point_size,
alpha=0.5,
color='blue3',
fill='skyblue2',
stroke=0.1) +
geom_point(data=mds_from_mix_neighbors(),
shape=21,
size=point_size,
alpha=0.75,
color='orange2',
fill='orange') +
geom_point(data=mds_from_mix_yes(),
shape=21,
size=point_size,
alpha=0.75,
color='red2',
fill='red')
} else {
p <- ggplot(NULL, aes(x=V1, y=V2, text=player_name)) +
geom_text(data=mds_from_mix_no(), aes(label=player_name), color='steelblue3', size=3) +
geom_text(data=mds_from_mix_neighbors(), aes(label=player_name), color='orange', size=3) +
geom_text(data=mds_from_mix_yes(), aes(label=player_name), color='red3', size=3) +
scale_x_continuous(expand = c(.15, .15))
}
p2 <- p +
theme_minimal() +
labs(title = NULL, x='Dimension 1*', y='Dimension 2*') +
theme(text = element_text(family='Source Sans Pro'),
axis.title.x = element_text(size=axis_text_size, face='italic'),
axis.title.y = element_text(size=axis_text_size, face='italic'),
axis.text.x = element_blank(),
axis.text.y = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
ggplotly(p2, tooltip = c('text')) %>%
layout(xaxis = list(side = 'top'))
})
# OUTPUT - neighbors list 2
output$neighbors_list_2 <- renderUI({
req(input$player_choice_2)
HTML(paste0('<br><b>Nearest neighbors:</b><br>', five_neighbors_from_mix_text_string()))
})
# OUTPUT - metrics list 2
output$metrics_list_2 <- renderUI({
req(input$player_choice_2)
HTML(paste0('<br><b>Pitch metrics:</b><br>', metrics_text_string_2(), '<br>'))
})
# OUTPUT - data table 2
output$neighbors_table_2 <- renderDataTable({
req(input$player_choice_2)
all_possible_neighbors_2()
},
rownames = FALSE,
options = list(
autoWidth = TRUE,
columnDefs = list(list(width = '5px', targets = 0),
list(width = '150px', targets = 1)),
dom = c('tp'),
pageLength = 10,
processing = FALSE
))
}
setwd('C:\\Users\\Sam\\Documents\\DATA\\MLB pitch mix\\Shiny App environment\\pitch-mix-shiny'); library(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
setwd('C:\\Users\\Sam\\Documents\\DATA\\MLB pitch mix\\GitHub environment\\shiny')
source('..\\r\\pitch_funcs.R')
pitches <- data.frame()
for(pitch in c('changeup', 'curveball', 'cutter', 'fastball2', 'fastball4', 'sinker', 'slider', 'splitter')){
df <- fread(paste0('..\\data\\', pitch, '.csv'))
df$pitch <- pitch_abbrvs[pitch]
pitches <- smartbind(pitches, df)
rm(df, pitch)
}
pitch_abbrvs <- c('changeup'='CH', 'curveball'='CU', 'cutter'='FC', 'fastball2'='FT', 'fastball4'='FF', 'sinker'='SI', 'slider'='SL', 'splitter'='SF')
pitches <- data.frame()
for(pitch in c('changeup', 'curveball', 'cutter', 'fastball2', 'fastball4', 'sinker', 'slider', 'splitter')){
df <- fread(paste0('..\\data\\', pitch, '.csv'))
df$pitch <- pitch_abbrvs[pitch]
pitches <- smartbind(pitches, df)
rm(df, pitch)
}
